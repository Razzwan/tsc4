{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

() recv_internal() {
}

const MAX_ASCII1 = 91;
const MIN_ASCII1 = 65;

const MAX_ASCII2 = 123;
const MIN_ASCII2 = 97;

(slice) shift_slice(int shift, slice text_slice, int bool) {
  builder body = begin_cell();

  do {
    int bit = text_slice~load_uint(8);

    if (bit < MAX_ASCII1) {
      if (bit >= MIN_ASCII1) {
        if (bool) {
          bit -= shift % (MAX_ASCII1 - MIN_ASCII1);
        } else {
          bit += shift % (MAX_ASCII1 - MIN_ASCII1);
        }

        if (bit >= MAX_ASCII1) {
          bit -= MAX_ASCII1 - MIN_ASCII1;
        }

        if (bit < MIN_ASCII1) {
          bit += MAX_ASCII1 - MIN_ASCII1;
        }
      }
    }

    if (bit < MAX_ASCII2) {
      if (bit >= MIN_ASCII2) {
        if (bool) {
          bit -= shift % (MAX_ASCII2 - MIN_ASCII2);
        } else {
          bit += shift % (MAX_ASCII2 - MIN_ASCII2);
        }

        if (bit >= MAX_ASCII2) {
          bit -= MAX_ASCII2 - MIN_ASCII2;
        }

        if (bit < MIN_ASCII2) {
          bit += MAX_ASCII2 - MIN_ASCII2;
        }
      }
    }

    body = store_int(body, bit, 8);
  } until (text_slice.slice_data_empty?());

  ifnot (text_slice.slice_refs_empty?()) {
    slice ref = shift_slice(shift, text_slice~load_ref().begin_parse(), bool);
    body = store_ref(body, begin_cell().store_slice(ref).end_cell());
  }

  return body.end_cell().begin_parse();
}

(cell) shift_text(int shift, cell text, int bool) {
  if (shift % 26 == 0) {
    return text;
  }

  (slice text_slice, slice flag) = text.begin_parse().load_bits(32);
  return begin_cell()
          .store_slice(flag)
          .store_slice(shift_slice(shift, text_slice, bool))
          .end_cell();
}

const SHIFT_TO_RIGHT = -1;

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
  return shift_text(shift, text, ~ SHIFT_TO_RIGHT);
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
  return shift_text(shift, text, SHIFT_TO_RIGHT);
}

